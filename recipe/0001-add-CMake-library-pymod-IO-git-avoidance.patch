From ad8ee076560199e12845542c869af358dfa1228a Mon Sep 17 00:00:00 2001
From: "Lori A. Burns" <lori.burns@gmail.com>
Date: Wed, 24 May 2023 10:58:57 -0400
Subject: [PATCH] add CMake, library, pymod, IO, git avoidance

---
 CMakeLists.txt                       | 153 +++++++++++++++++++++++++
 cmake/CheckFortranCompilerFlag.cmake |  71 ++++++++++++
 cmake/autocmake_omp.cmake            |  72 ++++++++++++
 cmake/autocmake_safeguards.cmake     |  27 +++++
 cmake/custom_static_library.cmake    |  56 +++++++++
 cmake/gdmaConfig.cmake.in            | 134 ++++++++++++++++++++++
 cmake/psi4OptionsTools.cmake         | 156 +++++++++++++++++++++++++
 examples/diff.py                     |   2 +-
 examples/formamide_psi4/HCONH2.psi4  |   2 +-
 examples/gdma_tests.py               |   4 +-
 pygdma/CMakeLists.txt                | 110 ++++++++++++++++++
 pygdma/bindings.cc.cmake.in          |  19 ++++
 src/atom_grids.f90                   |  53 +++++----
 src/dma.f90                          | 116 ++++++++++++-------
 src/exe.f90                          | 163 +++++++++++++++++++++++++++
 src/gdma.f90                         | 161 +++++++++++++++++++-------
 src/input.F90                        |   6 +-
 src/version.py                       |  12 +-
 18 files changed, 1197 insertions(+), 120 deletions(-)
 create mode 100644 CMakeLists.txt
 create mode 100644 cmake/CheckFortranCompilerFlag.cmake
 create mode 100644 cmake/autocmake_omp.cmake
 create mode 100644 cmake/autocmake_safeguards.cmake
 create mode 100644 cmake/custom_static_library.cmake
 create mode 100644 cmake/gdmaConfig.cmake.in
 create mode 100644 cmake/psi4OptionsTools.cmake
 create mode 100644 pygdma/CMakeLists.txt
 create mode 100644 pygdma/bindings.cc.cmake.in
 create mode 100644 src/exe.f90

diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
index 0000000..3991e02
--- /dev/null
+++ b/CMakeLists.txt
@@ -0,0 +1,153 @@
+cmake_policy(SET CMP0048 NEW)
+cmake_minimum_required(VERSION 3.16)
+project(gdma
+        VERSION 2.3.3
+        LANGUAGES C Fortran)
+set(gdma_AUTHORS      "Anthony J. Stone")
+set(gdma_DESCRIPTION  "Gaussian Distributed Multipole Analysis")
+set(gdma_URL          "https://www-stone.ch.cam.ac.uk/pub/gdma/")
+set(gdma_LICENSE      "GNU General Public License, version 3")
+
+list(APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake)
+
+################################### Options ####################################
+include(psi4OptionsTools)
+option_with_default(CMAKE_BUILD_TYPE "Build type" Release)
+option_with_print(BUILD_SHARED_LIBS "Build final library as shared, not static" OFF)
+option_with_default(BUILD_FPIC "Compile static libraries with position independent code" ON)
+option_with_print(ENABLE_OPENMP "Enable threadsafe linking to OpenMP parallelized programs." ON)
+option_with_default(CMAKE_INSTALL_LIBDIR "Directory to which libraries installed" lib)
+option_with_default(PYMOD_INSTALL_LIBDIR "If gdma_ENABLE_PYTHON, location within CMAKE_INSTALL_LIBDIR to which python modules are installed" /)
+option_with_print(ENABLE_GENERIC "Enable mostly static linking in shared library" OFF)
+option_with_flags(ENABLE_XHOST "Enable processor-specific optimization" ON
+                    "-xHost" "-march=native")
+option_with_default(ENABLE_GENERIC "Enables mostly static linking of system and math libraries for shared library" OFF)
+option_with_default(gdma_INSTALL_CMAKEDIR "Directory to which gdma CMake config files installed." share/cmake/gdma)
+option_with_print(gdma_ENABLE_PYTHON "Build Python bindings (requires Python and Pybind11)" OFF)
+
+######################### Process & Validate Options ###########################
+include(autocmake_safeguards)
+include(autocmake_omp)
+include(custom_static_library)
+
+set(CMAKECONFIG_INSTALL_DIR "${gdma_INSTALL_CMAKEDIR}")
+
+################################# Main Project #################################
+include(GNUInstallDirs)
+include(FortranCInterface)
+include(CMakePackageConfigHelpers)
+
+set(gdma ${PROJECT_NAME})
+
+# <<<  Build  >>>
+
+FortranCInterface_HEADER(GDMA_MANGLE.h
+                         MACRO_NAMESPACE "GDMA_MANGLE_"
+                         SYMBOL_NAMESPACE "GDMA_MANGLE_")
+set(raw_sources_list atom_grids.f90
+                     dma.f90
+                     gdma.f90
+                     input.F90
+                     timing.F90)
+set(src_prefix "src/")
+string(REGEX REPLACE "([^;]+)" "${src_prefix}\\1" sources_list "${raw_sources_list}")
+
+find_package(Python COMPONENTS Interpreter REQUIRED)
+# avoid overlong compiler names in Fortran src file. sometimes balks on line length.
+get_filename_component(_compiler_name ${CMAKE_Fortran_COMPILER} NAME)
+add_custom_command(
+  OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/version.f90
+  #COMMAND ${Python_EXECUTABLE} version.py ../VERSION ${CMAKE_CURRENT_BINARY_DIR}/version.f90 ${_compiler_name}
+  COMMAND ${Python_EXECUTABLE} version.py ../VERSION ${CMAKE_CURRENT_BINARY_DIR}/version.f90 ${_compiler_name} --commit c2e0b548  # TODO
+  WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/src
+  COMMENT "Generating version info"
+  )
+
+# STATIC/SHARED on below governed by BUILD_SHARED_LIBS
+add_library(gdma ${sources_list} ${CMAKE_CURRENT_BINARY_DIR}/version.f90)
+add_library(gdma::gdma ALIAS gdma)
+if (NOT ${BUILD_SHARED_LIBS})
+    set_target_properties(gdma PROPERTIES POSITION_INDEPENDENT_CODE ${BUILD_FPIC})
+endif()
+if(${BUILD_SHARED_LIBS})
+    target_link_libraries(gdma PRIVATE ${LIBC_INTERJECT})
+
+    if(APPLE)
+        set_target_properties(gdma PROPERTIES LINK_FLAGS "-undefined dynamic_lookup")
+    endif()
+endif()
+
+set(export_properties
+  "gdma_VERSION"
+  )
+set_target_properties(gdma PROPERTIES gdma_VERSION ${gdma_VERSION})
+set_property(TARGET gdma APPEND PROPERTY EXPORT_PROPERTIES "${export_properties}")
+
+add_executable(gdmaexe src/exe.f90)
+add_executable(gdma::exe ALIAS gdmaexe)
+target_link_libraries(gdmaexe gdma)
+set_target_properties(gdmaexe
+  PROPERTIES
+    INSTALL_RPATH "$ORIGIN/../${CMAKE_INSTALL_LIBDIR}"
+    EXPORT_NAME "exe"
+    OUTPUT_NAME "gdma"
+  )
+
+# Python directory
+if (gdma_ENABLE_PYTHON)
+    add_subdirectory(pygdma)
+endif()
+
+# <<<  Install  >>>
+
+install(FILES ${PROJECT_BINARY_DIR}/GDMA_MANGLE.h
+        DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/GDMA)
+install(
+  TARGETS
+    gdma
+    gdmaexe
+  EXPORT
+    library_interface
+  RUNTIME DESTINATION
+    ${CMAKE_INSTALL_BINDIR}
+  ARCHIVE DESTINATION
+    ${CMAKE_INSTALL_LIBDIR}
+  LIBRARY DESTINATION
+    ${CMAKE_INSTALL_LIBDIR}
+  PUBLIC_HEADER DESTINATION
+    ${CMAKE_INSTALL_INCLUDEDIR}
+  )
+
+# <<<  Export Interface  >>>
+
+target_compile_definitions(gdma INTERFACE USING_${gdma})
+target_include_directories(gdma INTERFACE
+                           $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>)
+
+# <<<  Export Config  >>>
+
+configure_package_config_file(cmake/${gdma}Config.cmake.in
+                              "${CMAKE_CURRENT_BINARY_DIR}/${gdma}Config.cmake"
+                              INSTALL_DESTINATION ${CMAKECONFIG_INSTALL_DIR})
+write_basic_package_version_file(${CMAKE_CURRENT_BINARY_DIR}/${gdma}ConfigVersion.cmake
+                                 VERSION ${${gdma}_VERSION}
+                                 COMPATIBILITY SameMajorVersion)
+install(
+  FILES
+    ${CMAKE_CURRENT_BINARY_DIR}/${gdma}Config.cmake
+    ${CMAKE_CURRENT_BINARY_DIR}/${gdma}ConfigVersion.cmake
+  DESTINATION
+    ${CMAKECONFIG_INSTALL_DIR}
+  )
+
+install(
+  EXPORT
+    library_interface
+  FILE
+    "${PROJECT_NAME}Targets-lib.cmake"
+  NAMESPACE
+    "${PROJECT_NAME}::"
+  DESTINATION
+    ${CMAKECONFIG_INSTALL_DIR}
+  )
+
diff --git a/cmake/CheckFortranCompilerFlag.cmake b/cmake/CheckFortranCompilerFlag.cmake
new file mode 100644
index 0000000..0a124f6
--- /dev/null
+++ b/cmake/CheckFortranCompilerFlag.cmake
@@ -0,0 +1,71 @@
+# Downloaded from
+#   https://github.com/Kitware/CMake/blob/master/Modules/CheckFortranCompilerFlag.cmake
+# * remove local copy when CMake >= 3.3 required
+
+#.rst:
+# CheckFortranCompilerFlag
+# ------------------------
+#
+# Check whether the Fortran compiler supports a given flag.
+#
+# CHECK_Fortran_COMPILER_FLAG(<flag> <var>)
+#
+# ::
+#
+#   <flag> - the compiler flag
+#   <var>  - variable to store the result
+#            Will be created as an internal cache variable.
+#
+# This internally calls the check_fortran_source_compiles macro and
+# sets CMAKE_REQUIRED_DEFINITIONS to <flag>.  See help for
+# CheckFortranSourceCompiles for a listing of variables that can
+# otherwise modify the build.  The result only tells that the compiler
+# does not give an error message when it encounters the flag.  If the
+# flag has any effect or even a specific one is beyond the scope of
+# this module.
+
+#=============================================================================
+# Copyright 2015 Nicolas Bock <nicolasbock@gmail.com>
+# Copyright 2006-2011 Kitware, Inc.
+# Copyright 2006 Alexander Neundorf <neundorf@kde.org>
+# Copyright 2011 Matthias Kretz <kretz@kde.org>
+#
+# Distributed under the OSI-approved BSD License (the "License");
+# see accompanying file Copyright.txt for details.
+#
+# This software is distributed WITHOUT ANY WARRANTY; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+# See the License for more information.
+#=============================================================================
+# (To distribute this file outside of CMake, substitute the full
+#  License text for the above reference.)
+
+include(CheckFortranSourceCompiles)
+include(CMakeCheckCompilerFlagCommonPatterns)
+
+macro (CHECK_Fortran_COMPILER_FLAG _FLAG _RESULT)
+  set(SAFE_CMAKE_REQUIRED_DEFINITIONS "${CMAKE_REQUIRED_DEFINITIONS}")
+  set(CMAKE_REQUIRED_DEFINITIONS "${_FLAG}")
+
+  # Normalize locale during test compilation.
+  set(_CheckFortranCompilerFlag_LOCALE_VARS LC_ALL LC_MESSAGES LANG)
+  foreach(v ${_CheckFortranCompilerFlag_LOCALE_VARS})
+    set(_CheckFortranCompilerFlag_SAVED_${v} "$ENV{${v}}")
+    set(ENV{${v}} C)
+  endforeach()
+  CHECK_COMPILER_FLAG_COMMON_PATTERNS(_CheckFortranCompilerFlag_COMMON_PATTERNS)
+  CHECK_Fortran_SOURCE_COMPILES("       program test\n       stop\n       end program" ${_RESULT}
+    # Some compilers do not fail with a bad flag
+    FAIL_REGEX "command line option .* is valid for .* but not for Fortran" # GNU
+    ${_CheckFortranCompilerFlag_COMMON_PATTERNS}
+    )
+  foreach(v ${_CheckFortranCompilerFlag_LOCALE_VARS})
+    set(ENV{${v}} ${_CheckFortranCompilerFlag_SAVED_${v}})
+    unset(_CheckFortranCompilerFlag_SAVED_${v})
+  endforeach()
+  unset(_CheckFortranCompilerFlag_LOCALE_VARS)
+  unset(_CheckFortranCompilerFlag_COMMON_PATTERNS)
+
+  set (CMAKE_REQUIRED_DEFINITIONS "${SAFE_CMAKE_REQUIRED_DEFINITIONS}")
+endmacro ()
+
diff --git a/cmake/autocmake_omp.cmake b/cmake/autocmake_omp.cmake
new file mode 100644
index 0000000..0ce6db7
--- /dev/null
+++ b/cmake/autocmake_omp.cmake
@@ -0,0 +1,72 @@
+# Downloaded from
+#   https://github.com/coderefinery/autocmake/blob/master/modules/omp.cmake
+# * moved option up
+# * toggled option default to ON
+# * reorganized logic for Fortran + C/CXX, see https://github.com/coderefinery/autocmake/issues/177
+
+#.rst:
+#
+# Enables OpenMP support.
+#
+# Variables used::
+#
+#   ENABLE_OPENMP
+#   OPENMP_FOUND
+#
+# Variables modified (provided the corresponding language is enabled)::
+#
+#   CMAKE_Fortran_FLAGS
+#   CMAKE_C_FLAGS
+#   CMAKE_CXX_FLAGS
+#
+# autocmake.yml configuration::
+#
+#   docopt: "--omp Enable OpenMP parallelization [default: False]."
+#   define: "'-DENABLE_OPENMP={0}'.format(arguments['--omp'])"
+
+if(ENABLE_OPENMP)
+
+    if(NOT OPENMP_FOUND)
+        find_package(OpenMP)
+    endif()
+
+    if(OPENMP_FOUND)
+        add_definitions(-DHAVE_OPENMP)
+        if(DEFINED CMAKE_C_COMPILER_ID)
+            set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${OpenMP_C_FLAGS}")
+        endif()
+        if(DEFINED CMAKE_CXX_COMPILER_ID)
+            set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${OpenMP_CXX_FLAGS}")
+        endif()
+        if(DEFINED CMAKE_Fortran_COMPILER_ID)
+            set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} ${OpenMP_Fortran_FLAGS}")
+        endif()
+    endif()
+
+    if(DEFINED CMAKE_Fortran_COMPILER_ID AND NOT DEFINED OpenMP_Fortran_FLAGS)
+        # we do this in a pedestrian way because the Fortran support is relatively recent
+        if(CMAKE_Fortran_COMPILER_ID MATCHES GNU)
+            set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -fopenmp")
+        endif()
+        if(CMAKE_Fortran_COMPILER_ID MATCHES Intel)
+            if(WIN32)
+                set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -Qopenmp")
+            elseif(CMAKE_Fortran_COMPILER_ID STREQUAL "Intel" AND
+                   "${CMAKE_Fortran_COMPILER_VERSION}" VERSION_LESS "15.0.0.20140528")
+                set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -openmp")
+            else()
+                set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -qopenmp")
+            endif()
+        endif()
+        if(CMAKE_Fortran_COMPILER_ID MATCHES PGI)
+            set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -mp")
+        endif()
+        if(CMAKE_Fortran_COMPILER_ID MATCHES XL)
+            set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -qsmp")
+        endif()
+        if(CMAKE_Fortran_COMPILER_ID MATCHES Cray)
+            # do nothing in this case
+        endif()
+        set(OPENMP_FOUND TRUE)
+    endif()
+endif()
diff --git a/cmake/autocmake_safeguards.cmake b/cmake/autocmake_safeguards.cmake
new file mode 100644
index 0000000..726dbcb
--- /dev/null
+++ b/cmake/autocmake_safeguards.cmake
@@ -0,0 +1,27 @@
+# Downloaded from
+#   https://github.com/coderefinery/autocmake/blob/master/modules/safeguards.cmake
+# * changed text of in-source message
+
+#.rst:
+#
+# Provides safeguards against in-source builds and bad build types.
+#
+# Variables used::
+#
+#   PROJECT_SOURCE_DIR
+#   PROJECT_BINARY_DIR
+#   CMAKE_BUILD_TYPE
+
+if(${PROJECT_SOURCE_DIR} STREQUAL ${PROJECT_BINARY_DIR})
+    message(FATAL_ERROR "In-source builds not allowed. Please run CMake from top directory and specify a build directory (e.g., cmake -S. -Bbuild).")
+endif()
+
+string(TOLOWER "${CMAKE_BUILD_TYPE}" cmake_build_type_tolower)
+string(TOUPPER "${CMAKE_BUILD_TYPE}" cmake_build_type_toupper)
+
+if(NOT cmake_build_type_tolower STREQUAL "debug" AND
+   NOT cmake_build_type_tolower STREQUAL "release" AND
+   NOT cmake_build_type_tolower STREQUAL "minsizerel" AND
+   NOT cmake_build_type_tolower STREQUAL "relwithdebinfo")
+    message(FATAL_ERROR "Unknown build type \"${CMAKE_BUILD_TYPE}\". Allowed values are Debug, Release, RelWithDebInfo, MinSizeRel (case-insensitive).")
+endif()
diff --git a/cmake/custom_static_library.cmake b/cmake/custom_static_library.cmake
new file mode 100644
index 0000000..d52f98b
--- /dev/null
+++ b/cmake/custom_static_library.cmake
@@ -0,0 +1,56 @@
+# Downloaded from
+#   https://github.com/PCMSolver/pcmsolver/blob/release/1.Y/cmake/custom/static_library.cmake
+# * suppressed STATIC_LIBRARY_ONLY
+# * moved option up
+# * corrected CXX block matches statements from C --> CXX compiler
+
+#.rst:
+#
+# Enables creation of static library.
+# If the shared library is created, make it as static as possible.
+#
+# Variables modified (provided the corresponding language is enabled)::
+#
+#   CMAKE_Fortran_FLAGS
+#   CMAKE_C_FLAGS
+#   CMAKE_CXX_FLAGS
+#
+# autocmake.cfg configuration::
+#
+#   docopt: --static Create only the static library [default: False].
+#   define: '-DSTATIC_LIBRARY_ONLY=%s' % arguments['--static']
+
+if(ENABLE_GENERIC)
+    if(DEFINED CMAKE_Fortran_COMPILER_ID)
+        if(CMAKE_Fortran_COMPILER_ID MATCHES GNU)
+            set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -static-libgfortran")
+        endif()
+        if(CMAKE_Fortran_COMPILER_ID MATCHES Intel)
+            set(CMAKE_Fortran_FLAGS "${CMAKE_Fortran_FLAGS} -static-libgcc -static-intel")
+        endif()
+    endif()
+
+    if(DEFINED CMAKE_C_COMPILER_ID)
+        if(CMAKE_C_COMPILER_ID MATCHES GNU)
+            set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -static-libgcc -fpic")
+        endif()
+        if(CMAKE_C_COMPILER_ID MATCHES Intel)
+            set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -static-libgcc -static-intel -wd10237")
+        endif()
+        if(CMAKE_C_COMPILER_ID MATCHES Clang)
+            set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fpic")
+        endif()
+    endif()
+
+    if(DEFINED CMAKE_CXX_COMPILER_ID)
+        if(CMAKE_CXX_COMPILER_ID MATCHES GNU)
+            set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -static-libstdc++ -static-libgcc")
+        endif()
+        if(CMAKE_CXX_COMPILER_ID MATCHES Intel)
+            set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wl,--as-needed -static-libstdc++ -static-libgcc -static-intel -wd10237")
+        endif()
+        if(CMAKE_CXX_COMPILER_ID MATCHES Clang)
+            set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -static-libstdc++")
+        endif()
+    endif()
+endif()
diff --git a/cmake/gdmaConfig.cmake.in b/cmake/gdmaConfig.cmake.in
new file mode 100644
index 0000000..afe2eb8
--- /dev/null
+++ b/cmake/gdmaConfig.cmake.in
@@ -0,0 +1,134 @@
+# gdmaConfig.cmake
+# -----------------
+#
+# gdma cmake module.
+# This module sets the following variables in your project::
+#
+#   gdma_FOUND - true if gdma and all required components found on the system
+#   gdma_VERSION - gdma version in format Major.Minor.Release. Prefer target variable.
+#   gdma_INCLUDE_DIRS - Directory where gdma/tensor.h header is located and dependent headers. Prefer targets.
+#   gdma_INCLUDE_DIR - same as DIRS. Prefer targets.
+#   gdma_DEFINITIONS - Definitions necessary to use gdma, namely USING_gdma. Prefer targets.
+#   gdma_LIBRARIES - gdma library to link against plus any dependent libraries. Prefer targets.
+#   gdma_LIBRARY - gdma library to link against. Prefer targets
+#   gdma_PYMOD - path to pygdma python module (suitable for appending PYTHONPATH). Only present
+#                 with Python component. Prefer pygdma target variable.
+#
+#
+# Target variables::
+#
+# It is preferred to use properties set on the base target rather than using the above variables. ::
+#
+#   gdma_VERSION - gdma version in format Major.Minor.Release
+#   gdma_PYMOD - path to gdma python module (suitable for appending PYTHONPATH). Only on pygdma target.
+#
+#   get_property(_ver TARGET gdma::gdma PROPERTY gdma_VERSION)
+#
+#
+# Available components: shared static Python ::
+#
+#   shared - search for only shared library
+#   static - search for only static library
+#   Python - search for Python bindings library
+#
+#
+# Exported targets::
+#
+# If gdma is found, this module defines at least the first following
+# :prop_tgt:`IMPORTED` target. Depending on components available, it may define::
+#
+#   gdma::gdma - the main gdma library with header & defs attached.
+#   gdma::exe - the usual gdma executable.
+#   gdma::pygdma - the Python pybind11 library.
+#
+#
+# Suggested usage::
+#
+#   find_package(gdma)
+#   find_package(gdma 2.2.3 CONFIG REQUIRED COMPONENTS shared)
+#
+#
+# The following variables can be set to guide the search for this package::
+#
+#   gdma_DIR - CMake variable, set to directory containing this Config file
+#   CMAKE_PREFIX_PATH - CMake variable, set to root directory of this package
+#   PATH - environment variable, set to bin directory of this package
+#   CMAKE_DISABLE_FIND_PACKAGE_gdma - CMake variable, disables
+#       find_package(gdma) perhaps to force internal build
+
+@PACKAGE_INIT@
+
+set(gdma gdma)  # NameSpace
+
+# check library style component
+if (@BUILD_SHARED_LIBS@)  # BUILD_SHARED_LIBS
+    set(${gdma}_shared_FOUND 1)
+else()
+    set(${gdma}_static_FOUND 1)
+endif()
+list(FIND ${gdma}_FIND_COMPONENTS "shared" _seek_shared)
+list(FIND ${gdma}_FIND_COMPONENTS "static" _seek_static)
+
+# check Python interface component
+if (EXISTS "${CMAKE_CURRENT_LIST_DIR}/${gdma}Targets-Python.cmake")
+    set(${gdma}_Python_FOUND 1)
+endif()
+list(FIND ${gdma}_FIND_COMPONENTS "Python" _seek_Python)
+
+# make detectable the FindTarget*.cmake modules
+list(APPEND CMAKE_MODULE_PATH ${CMAKE_CURRENT_LIST_DIR})
+
+# Check all required components are available before trying to load any
+check_required_components(${gdma})
+
+#-----------------------------------------------------------------------------
+# Don't include targets if this file is being picked up by another
+# project which has already built this as a subproject
+#-----------------------------------------------------------------------------
+if(NOT TARGET ${gdma}::gdma)
+    include("${CMAKE_CURRENT_LIST_DIR}/${gdma}Targets-lib.cmake")
+
+    get_property(_loc TARGET ${gdma}::gdma PROPERTY LOCATION)
+    get_property(_ill TARGET ${gdma}::gdma PROPERTY INTERFACE_LINK_LIBRARIES)
+    get_property(_iid TARGET ${gdma}::gdma PROPERTY INTERFACE_INCLUDE_DIRECTORIES)
+    get_property(_icd TARGET ${gdma}::gdma PROPERTY INTERFACE_COMPILE_DEFINITIONS)
+    set(${gdma}_LIBRARY ${_loc})
+    set(${gdma}_LIBRARIES ${_loc};${_ill})
+    set(${gdma}_INCLUDE_DIR ${_iid})
+    set(${gdma}_INCLUDE_DIRS ${_iid})
+    set(${gdma}_DEFINITIONS ${_icd})
+
+    if(${gdma}_Python_FOUND)
+        include("${CMAKE_CURRENT_LIST_DIR}/${gdma}Targets-Python.cmake")
+        get_property(${gdma}_PYMOD TARGET ${gdma}::pygdma PROPERTY gdma_PYMOD)
+    endif()
+
+    if (CMAKE_VERSION VERSION_GREATER 3.15)
+        message(VERBOSE "gdma::gdma")
+
+        get_property(_ver TARGET ${gdma}::gdma PROPERTY gdma_VERSION)
+        message(VERBOSE "${gdma}::gdma.${gdma}_VERSION   ${_ver}")
+
+        message(VERBOSE "${gdma}_FOUND                  ${${gdma}_FOUND}")
+        message(VERBOSE "${gdma}_VERSION                ${${gdma}_VERSION}")
+        message(VERBOSE "${gdma}_DEFINITIONS            ${${gdma}_DEFINITIONS}")
+
+        message(VERBOSE "${gdma}_LIBRARY                ${${gdma}_LIBRARY}")
+        message(VERBOSE "${gdma}_LIBRARIES              ${${gdma}_LIBRARIES}")
+        message(VERBOSE "${gdma}_INCLUDE_DIR            ${${gdma}_INCLUDE_DIR}")
+        message(VERBOSE "${gdma}_INCLUDE_DIRS           ${${gdma}_INCLUDE_DIRS}")
+
+        if (TARGET ${gdma}::pygdma)
+            message(VERBOSE "gdma::pygdma")
+
+            get_property(_ver TARGET ${gdma}::pygdma PROPERTY gdma_VERSION)
+            get_property(_pym TARGET ${gdma}::pygdma PROPERTY gdma_PYMOD)
+            message(VERBOSE "${gdma}::pygdma.${gdma}_VERSION ${_ver}")
+            message(VERBOSE "${gdma}::pygdma.${gdma}_PYMOD   ${_pym}")
+
+            message(VERBOSE "${gdma}_VERSION                ${${gdma}_VERSION}")
+            message(VERBOSE "${gdma}_PYMOD                  ${${gdma}_PYMOD}")
+        endif()
+    endif()
+
+endif()
diff --git a/cmake/psi4OptionsTools.cmake b/cmake/psi4OptionsTools.cmake
new file mode 100644
index 0000000..1657978
--- /dev/null
+++ b/cmake/psi4OptionsTools.cmake
@@ -0,0 +1,156 @@
+###This file contains functions used throughout the Psi4 build.  Like source
+###code, the build system should be factored and common code extracted out into
+###functions/macros.  If you find repetitive code throughout the build scripts
+###this is the place to add it (make sure you document it too).
+
+#Macro for printing an option in a consistent manner
+#
+#Syntax: print_option(<option to print> <was specified>)
+#
+macro(print_option variable default)
+if(NOT DEFINED ${variable} OR "${${variable}}" STREQUAL "")
+    message(STATUS "Setting (unspecified) option ${variable}: ${default}")
+else()
+    message(STATUS "Setting option ${variable}: ${${variable}}")
+endif()
+endmacro()
+
+# Wraps an option with default ON/OFF. Adds nice messaging to option()
+#
+#Syntax: option_with_print(<option name> <description> <default value>)
+#
+macro(option_with_print variable msge default)
+   print_option(${variable} ${default})
+   option(${variable} ${msge} ${default})
+endmacro(option_with_print)
+
+#Wraps an option with a default other than ON/OFF and prints it
+#NOTE: Can't combine with above b/c CMake handles ON/OFF options specially
+#NOTE2: CMAKE_BUILD_TYPE (and other CMake variables) are always defined so need
+#       to further check for if they are the NULL string.  This is also why we
+#       need the force
+#
+#Syntax: option_with_default(<option name> <description> <default value>)
+#
+macro(option_with_default variable msge default)
+print_option(${variable} ${default})
+if(NOT DEFINED ${variable} OR "${${variable}}" STREQUAL "")
+   set(${variable} ${default} CACHE STRING ${msge} FORCE)
+endif()
+endmacro(option_with_default)
+
+include(CheckCCompilerFlag)
+include(CheckCXXCompilerFlag)
+if(CMAKE_Fortran_COMPILER)
+    include(CheckFortranCompilerFlag)  # CMake >= 3.3, so local copy in cmake/
+endif()
+
+#The guts of the next two functions, use the wrappers please
+#
+#Syntax: add_C_or_CXX_flags(<True for C, False for CXX>)
+#
+# Note: resist adding -Werror to the check_X_compiler_flag calls,
+#   as (i) the flag for Intel is actually -diag-error warn, (ii)
+#   Intel ifort doesn't define -Werror, and (iii) passing it
+#   changes REQUIRED_DEFINITIONS.
+macro(add_C_or_CXX_flags is_C)
+set(CMAKE_REQUIRED_QUIET_SAVE ${CMAKE_REQUIRED_QUIET})
+   set(CMAKE_REQUIRED_QUIET ON)
+   set(flags_to_try "${ARGN}")
+   foreach(flag_i IN LISTS flags_to_try ITEMS -brillig)
+      if(${flag_i} STREQUAL "-brillig")
+         message(WARNING "Option unfulfilled as none of ${flags_to_try} valid")
+         break()
+      endif()
+      unset(test_option CACHE)
+      if(${is_C} EQUAL 0)
+          CHECK_C_COMPILER_FLAG("${flag_i}" test_option)
+          set(description_to_print CMAKE_C_FLAGS)
+      elseif(${is_C} EQUAL 1)
+          CHECK_CXX_COMPILER_FLAG("${flag_i}" test_option)
+          set(description_to_print CMAKE_CXX_FLAGS)
+      elseif(${is_C} EQUAL 2)
+          CHECK_Fortran_COMPILER_FLAG("${flag_i}" test_option)
+          set(description_to_print CMAKE_Fortran_FLAGS)
+      endif()
+      set(msg_base "Performing Test ${description_to_print} [${flag_i}] -")
+      if(${test_option})
+        set(${description_to_print} "${${description_to_print}} ${flag_i}")
+        if(NOT CMAKE_REQUIRED_QUIET_SAVE)
+           message(STATUS  "${msg_base} Success, Appending")
+        endif()
+        break()
+      else()
+        if(NOT CMAKE_REQUIRED_QUIET_SAVE)
+           message(STATUS "${msg_base} Failed")
+        endif()
+      endif()
+   endforeach()
+   set(CMAKE_REQUIRED_QUIET ${CMAKE_REQUIRED_QUIET_SAVE})  
+endmacro()
+
+
+
+#Checks if C flags are valid, if so adds them to CMAKE_C_FLAGS
+#Input should be a list of flags to try.  If two flags are to be tried together
+#enclose them in quotes, e.g. "-L/path/to/dir -lmylib" is tried as a single
+#flag, whereas "-L/path/to/dir" "-lmylib" is tried as two separate flags.
+#The first list item to succeed is added to CMAKE_C_FLAGS, then try loop
+#breaks. Warning issued if no flags in list succeed.
+#
+#
+#Syntax: add_C_flags(<flags to add>)
+#
+macro(add_C_flags)
+   add_C_or_CXX_flags(0 ${ARGN})
+endmacro()
+
+#Checks if CXX flags are valid, if so adds them to CMAKE_CXX_FLAGS
+#See add_C_flags for more info on syntax
+#
+#Syntax: add_CXX_flags(<flags to add>)
+#
+macro(add_CXX_flags)
+    add_C_or_CXX_flags(1 ${ARGN})
+endmacro()
+
+#Checks if Fortran flags are valid, if so adds them to CMAKE_Fortran_FLAGS
+#See add_C_flags for more info on syntax
+#
+#Syntax: add_Fortran_flags(<flags to add>)
+#
+macro(add_Fortran_flags)
+    add_C_or_CXX_flags(2 ${ARGN})
+endmacro()
+
+#Macro for adding flags common to both C and CXX, if the compiler supports them
+#
+#Syntax: add_flags(<flags to add>)
+#
+macro(add_flags FLAGS)
+    get_property(languages GLOBAL PROPERTY ENABLED_LANGUAGES)
+    list(FIND languages "C" _index_c)
+    list(FIND languages "CXX" _index_cxx)
+    list(FIND languages "Fortran" _index_fortran)
+    if (${_index_c} GREATER -1)
+        add_C_flags(${FLAGS})
+    endif()
+    if (${_index_cxx} GREATER -1)
+        add_CXX_flags(${FLAGS})
+    endif()
+    if (${_index_fortran} GREATER -1)
+        add_Fortran_flags(${FLAGS})
+    endif()
+endmacro()
+
+#Defines an option that if enabled turns on some compiler flags
+#
+#Syntax: option_with_flags(<option> <description> <default value> <flags>)
+#
+macro(option_with_flags option msg default)
+    print_option(${option} ${default})
+    option(${option} ${msg} ${default})
+    if(${${option}})
+       add_flags("${ARGN}")
+    endif()
+endmacro()
diff --git a/examples/diff.py b/examples/diff.py
index 111696a..1f3d0f5 100755
--- a/examples/diff.py
+++ b/examples/diff.py
@@ -1,4 +1,4 @@
-#!/usr/bin/python3
+#!/usr/bin/env python
 #  -*-  coding:  utf-8  -*-
 
 """Check test output against check files.
diff --git a/examples/formamide_psi4/HCONH2.psi4 b/examples/formamide_psi4/HCONH2.psi4
index ea1d5ea..0caa5cc 100755
--- a/examples/formamide_psi4/HCONH2.psi4
+++ b/examples/formamide_psi4/HCONH2.psi4
@@ -1,4 +1,4 @@
-#!/usr/bin/python3
+#!/usr/bin/env python
 #  -*-  coding:  utf-8  -*-
 
 import os, sys
diff --git a/examples/gdma_tests.py b/examples/gdma_tests.py
index cac5c85..def32d2 100755
--- a/examples/gdma_tests.py
+++ b/examples/gdma_tests.py
@@ -1,4 +1,4 @@
-#!/usr/bin/python3
+#!/usr/bin/env python
 #  -*-  coding:  utf-8  -*-
 
 """Run the gdma tests.
@@ -47,7 +47,7 @@ for test in tests:
     for f in ["out", "punch"]:
         if os.path.exists(f): os.remove(f)
     with open("data") as D, open("out","w") as OUT:
-        rc = subprocess.call([program], stdin=D, stdout=OUT, stderr=subprocess.STDOUT)
+        rc = subprocess.call([args.p], stdin=D, stdout=OUT, stderr=subprocess.STDOUT)
     if rc != 0:
         print(f"GDMA failed with return code {rc:1d}")
     else:
diff --git a/pygdma/CMakeLists.txt b/pygdma/CMakeLists.txt
new file mode 100644
index 0000000..157c71d
--- /dev/null
+++ b/pygdma/CMakeLists.txt
@@ -0,0 +1,110 @@
+if (CMAKE_HOST_WIN32)
+    cmake_minimum_required(VERSION 3.21)
+else()
+    cmake_minimum_required(VERSION 3.16)
+endif()
+cmake_policy(SET CMP0079 NEW)
+project(
+  pygdma
+  VERSION 2.3.3  # SYNC WITH `project(gdma VERSION <>)` in <top_level>/CMakeLists.txt
+  LANGUAGES CXX
+  )
+set(pygdma_AUTHORS      "Anthony J. Stone")
+set(pygdma_DESCRIPTION  "Gaussian Distributed Multipole Analysis")
+set(pygdma_URL          "https://www-stone.ch.cam.ac.uk/pub/gdma/")
+set(pygdma_LICENSE      "GNU General Public License, version 3")
+
+list(APPEND CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/../cmake)
+
+################################### Options ####################################
+include(psi4OptionsTools)
+option_with_default(CMAKE_BUILD_TYPE "Build type (Release or Debug)" Release)
+option_with_default(PYMOD_INSTALL_LIBDIR "Location within CMAKE_INSTALL_LIBDIR to which python modules are installed" /)
+option_with_default(gdma_INSTALL_CMAKEDIR "Directory to which gdma CMake config files installed." share/cmake/gdma)
+
+################################# Main Project #################################
+include(autocmake_safeguards)
+include(GNUInstallDirs)
+set(CMAKECONFIG_INSTALL_DIR "${gdma_INSTALL_CMAKEDIR}")
+
+set(Python_ADDITIONAL_VERSIONS 3.11 3.10 3.9 3.8 3.7)  # adjust with CMake minimum FindPythonInterp
+find_package(Python 3.7 COMPONENTS Interpreter Development REQUIRED)
+message(STATUS "Found Python ${Python_VERSION_MAJOR}.${Python_VERSION_MINOR}: ${Python_EXECUTABLE} (found version ${Python_VERSION})")
+
+if (NOT TARGET pybind11::pybind11)
+    find_package(pybind11 CONFIG REQUIRED)
+endif()
+
+if (APPLE)
+    set(base "@loader_path")
+else()
+    set(base "$ORIGIN")
+endif()
+file(RELATIVE_PATH relDir ${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}${PYMOD_INSTALL_LIBDIR}
+                          ${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR})
+set(CMAKE_INSTALL_RPATH ${base} ${base}/${relDir})
+
+message(STATUS "pygdma rpath: ${CMAKE_INSTALL_RPATH}")
+
+configure_file(bindings.cc.cmake.in bindings.cc @ONLY)  # bake in version string
+pybind11_add_module(pygdma MODULE bindings.cc)
+target_compile_features(pygdma PRIVATE "cxx_std_17")
+add_library(gdma::pygdma ALIAS pygdma)
+
+if(NOT TARGET gdma::gdma)
+    find_package(gdma CONFIG REQUIRED)
+endif()
+target_link_libraries(pygdma PRIVATE gdma::gdma)
+
+if(MSVC)
+    target_compile_definitions(pygdma PUBLIC _USE_MATH_DEFINES)
+    target_compile_options(pygdma PUBLIC "/EHsc")
+    set_target_properties(
+      pygdma
+      PROPERTIES
+        WINDOWS_EXPORT_ALL_SYMBOLS ON
+      )
+endif()
+
+set(export_properties
+  "gdma_VERSION"
+  "gdma_PYMOD"
+  )
+
+set_target_properties(
+  pygdma
+  PROPERTIES
+    OUTPUT_NAME gdma
+    EXPORT_NAME pygdma
+    INSTALL_RPATH "${CMAKE_INSTALL_RPATH}"
+    # below two are covered by pb11. Use pybind11_add_module(... NO_EXTRAS) to experiment here.
+    # CXX_VISIBILITY_PRESET "hidden"
+    # VISIBILITY_INLINES_HIDDEN 1
+    gdma_VERSION ${pygdma_VERSION}
+    gdma_PYMOD "${CMAKE_INSTALL_PREFIX}/${CMAKE_INSTALL_LIBDIR}${PYMOD_INSTALL_LIBDIR}"
+    EXPORT_PROPERTIES "${export_properties}"
+  )
+
+# It's not clear whether Python bindings should get a Config.cmake file and/or a separate project().
+#   See https://github.com/jturney/ambit/blob/master/pyambit/CMakeLists.txt#L88 for discussion, esp. for packagers.
+
+install(
+  TARGETS
+    pygdma
+  EXPORT
+    python_interface
+  LIBRARY DESTINATION
+    ${CMAKE_INSTALL_LIBDIR}${PYMOD_INSTALL_LIBDIR}
+  )
+
+install(
+  EXPORT
+    python_interface
+  FILE
+    "gdmaTargets-Python.cmake"
+  NAMESPACE
+    "gdma::"
+  DESTINATION
+    ${CMAKECONFIG_INSTALL_DIR}
+  )
+
diff --git a/pygdma/bindings.cc.cmake.in b/pygdma/bindings.cc.cmake.in
new file mode 100644
index 0000000..e72ce53
--- /dev/null
+++ b/pygdma/bindings.cc.cmake.in
@@ -0,0 +1,19 @@
+#include <pybind11/pybind11.h>
+
+extern "C" void run_gdma(const char* outfilename, const char* datfilename);
+extern "C" int get_nsites();
+extern "C" int get_order(int site);
+extern "C" double get_dma_value(int site, int addr);
+extern "C" double get_tot_value(int addr);
+
+PYBIND11_MODULE(gdma, m) {
+    
+    m.def("run_gdma", &run_gdma,
+          "Execute the GDMA analysis with input directives from the file named in the second argument (FCHK file specified therein) and direct output to the file named in the first argument.");
+    m.def("get_nsites", &get_nsites, "Return count of sites at which multipoles are placed in DMA analysis.");
+    m.def("get_order", &get_order, "Return multipole order for site in first argument (1-indexed).");
+    m.def("get_dma_value", &get_dma_value, "Return the spherical harmonic DMA for the site in the first argument for component in the second argument (both 1-indexed).");
+    m.def("get_tot_value", &get_tot_value, "Return the total multipoles translated to the origin for component in first argument (1-indexed).");
+    m.attr("__version__") = "@pygdma_VERSION@";
+}
+
diff --git a/src/atom_grids.f90 b/src/atom_grids.f90
index f6f39f2..6cf7211 100644
--- a/src/atom_grids.f90
+++ b/src/atom_grids.f90
@@ -63,6 +63,7 @@ INTEGER, SAVE :: n_r=80, n_a=590, k_mu=3, m_r=2
 !  Bragg-Slater radii from Slater, JCP (1964) 41, 3199. Inert gases
 !  added with same radius as preceding halogen. Hydrogen radius is
 !  twice the Slater value. These values are in Angstrom.
+INTEGER :: outfile
 REAL(dp) :: slater_radius(0:54) = (/ 0.65d0, 0.50d0, 0.50d0,           &
     1.45d0, 1.05d0, 0.85d0, 0.70d0, 0.65d0, 0.60d0, 0.50d0, 0.50d0,    &
     1.80d0, 1.50d0, 1.25d0, 1.10d0, 1.00d0, 1.00d0, 1.00d0, 1.00d0,    &
@@ -224,7 +225,7 @@ INTEGER :: sleg(16)=(/0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120/)
 
 CONTAINS
 
-SUBROUTINE make_grid(ns, zs, c, radius)
+SUBROUTINE make_grid(ns, zs, c, radius, of)
 IMPLICIT NONE
 
 !  ns is the number of DMA sites. c(:,k) specifies the position of site
@@ -233,22 +234,24 @@ IMPLICIT NONE
 !  true, in which case it controls the Becke partitioning of space between
 !  sites. The atomic number controls the scale of the radial grid.
 
-INTEGER, INTENT(IN) :: ns, zs(:)
+INTEGER, INTENT(IN) :: ns, zs(:), of
 REAL(dp), INTENT(IN) :: c(:,:), radius(:)
 
 INTEGER :: a, b, g, i, m, ma, mb, n, p, q, ok
 REAL(dp), ALLOCATABLE :: rr(:,:), aa(:,:), s(:,:), pp(:)
 REAL(dp) :: chi, u, mu_ab, nu_ab, weight, f
 
+outfile = of
+
 !  Arrays used for Becke weighting
 allocate (gr(ns), rr(ns,ns), aa(ns,ns), s(ns,ns), pp(ns), stat=ok)
 if (ok > 0) then
-  print "(a)", "Make_grid: Allocation failed"
+  write(outfile, "(a)") "Make_grid: Allocation failed"
   stop
 else
-  ! print "(a)", "Make_grid: Allocation done"
+  ! write(outfile, "(a)") "Make_grid: Allocation done"
 end if
-print "(a,i0,a)", "Using ", n_r, "-point Euler-MacLaurin radial quadrature"
+write(outfile, "(a,i0,a)") "Using ", n_r, "-point Euler-MacLaurin radial quadrature"
 
 !  Angular grid
 call angular_grid(n_a)
@@ -259,10 +262,10 @@ if (allocated(grid)) then
 end if
 allocate(grid(4,ng),stat=ok)
 if (ok>0) then
-  print "(a,i0,a)", "Main grid allocation failed: ", 32*ng, " bytes needed"
+  write(outfile, "(a,i0,a)") "Main grid allocation failed: ", 32*ng, " bytes needed"
   stop
 else
-  ! print "(a,i0,a)", "Main grid allocation done: ", ng, " points"
+  ! write(outfile, "(a,i0,a)") "Main grid allocation done: ", ng, " points"
 end if
 
 !  Construct grids around each atom
@@ -285,7 +288,7 @@ do n=1,ns
 end do
 start(ns+1)=g+1
 if (g>ng) then
-  print "(a,i0,a)", "Not enough grid points allocated -- ", g, " needed"
+  write(outfile, "(a,i0,a)") "Not enough grid points allocated -- ", g, " needed"
   stop
 end if
 ng=g
@@ -294,12 +297,12 @@ if (ns > 1) then
   !  Assign weight to each point according to Becke formula.
   !  rr(m,n) is the distance between nuclei m and n.
 !  if (Slater) then
-!    print "(a)", "Using specified atom radii for Becke weighting"
+!    write(outfile, "(a)") "Using specified atom radii for Becke weighting"
 !    do a=1,ns
 !      atom_radius(a)=radius(a)
 !    end do
 !  else
-!    print "(a)", "Using equal atom radii for Becke weighting"
+!    write(outfile, "(a)") "Using equal atom radii for Becke weighting"
 !    atom_radius(1:ns)=1d0
 !  end if
   do a=1,ns
@@ -314,7 +317,7 @@ if (ns > 1) then
     end do
   end do
 
-  print "(a,i0)", "Becke smoothing parameter = ", k_mu
+  write(outfile, "(a,i0)") "Becke smoothing parameter = ", k_mu
   a=0
   do g=1,ng
     if (g .ge. start(a+1)) a=a+1
@@ -342,8 +345,8 @@ if (ns > 1) then
     grid(4,g)=grid(4,g)*weight
     if (debug) then
       if (grid(1,g)**2+grid(2,g)**2<1d-6) then
-        print "(i1, 3f12.5, 2f16.5)", a, grid(:,g), weight
-        print "(3f20.8)", (s(i,:), i=1,ns), pp
+        write(outfile, "(i1, 3f12.5, 2f16.5)") a, grid(:,g), weight
+        write(outfile, "(3f20.8)") (s(i,:), i=1,ns), pp
       end if
     end if
   end do
@@ -378,18 +381,18 @@ REAL(dp) :: f
 if (.not. allocated(w_r)) then
   allocate (w_r(n_r), r(n_r), stat=ok)
   if (ok>0) then
-    print "(a)", "Radial_grid: allocation failed"
+    write(outfile, "(a)") "Radial_grid: allocation failed"
   else
-    ! print "(a)", "Radial_grid: allocation done"
+    ! write(outfile, "(a)") "Radial_grid: allocation done"
   end if
 end if
 
 f=m_r*n_r*alpha**3
-! print "(a, i0)", "Radial points for atom ", n
+! write(outfile, "(a, i0)") "Radial points for atom ", n
 do i=1,n_r-1
   r(i)=alpha*(real(i,dp)/real(n_r-i,dp))**m_r
   w_r(i)=f*real(i,dp)**(3*m_r-1)/(real(n_r-i,dp)**(3*m_r+1))
-  ! print "(f12.7,e16.7)", r(i), w_r(i)
+  ! write(outfile, "(f12.7,e16.7)") r(i), w_r(i)
 end do
 
 END SUBROUTINE radial_grid
@@ -399,7 +402,7 @@ SUBROUTINE test_angular_grid(n)
 INTEGER :: n !, i
 
 call Lbdv(n)
-! print "(4f20.16)", (x(i), y(i), z(i), w(i), i=1,n)
+! write(outfile, "(4f20.16)") (x(i), y(i), z(i), w(i), i=1,n)
 
 END SUBROUTINE test_angular_grid
 
@@ -409,7 +412,7 @@ INTEGER :: n
 
 if (Lebedev) then
   call Lbdv(n)
-  print "(a,i0,a)", "Using ", n, "-point Lebedev quadrature"
+  write(outfile, "(a,i0,a)") "Using ", n, "-point Lebedev quadrature"
 else
   call gauss(n)
 end if
@@ -431,17 +434,17 @@ n=2*m*m
 
 k=sleg(m)
 if (k .eq. 0) then
-  print "(a,i0,a)", "No points or weights for ",                       &
+  write(outfile, "(a,i0,a)") "No points or weights for ",                       &
       m, "-point Gauss-Legendre quadrature"
   stop
 else
-  print "(a,i0,a)", "Using ", m, "-point Gauss-Legendre quadrature in theta"
-  print "(a,i0,a)", "and ", 2*m, "-point uniform quadrature in phi"
+  write(outfile, "(a,i0,a)") "Using ", m, "-point Gauss-Legendre quadrature in theta"
+  write(outfile, "(a,i0,a)") "and ", 2*m, "-point uniform quadrature in phi"
 end if
 
 allocate (x(n), y(n), z(n), w(n), stat=ok)
 if (ok>0) then
-  print "(a)", "Allocation failed"
+  write(outfile, "(a)") "Allocation failed"
   stop
 end if
 
@@ -550,7 +553,7 @@ end if
 ! end select
 allocate (x(n), y(n), z(n), w(n), stat=ok)
 if (ok>0) then
-  print "(a)", "Allocation failed"
+  write(outfile, "(a)") "Allocation failed"
   stop
 end if
 select case(n)
@@ -692,7 +695,7 @@ REAL(dp) :: c
 !       goto (1,2,3,4,5,6) code
 select case(code)
 case default
-  print "(a,i0)", 'Gen_Oh: Invalid Code ', code
+  write(outfile, "(a,i0)") 'Gen_Oh: Invalid Code ', code
   stop
 case(1)
   a=1.0d0
diff --git a/src/dma.f90 b/src/dma.f90
index 41a2bf8..962e8fa 100644
--- a/src/dma.f90
+++ b/src/dma.f90
@@ -20,6 +20,7 @@ MODULE DMA
 !  Fifth Floor, Boston, MA 02110-1301, USA.
 
 
+use iso_c_binding
 USE atom_grids, ONLY : grid, ng, make_grid, Lebedev,                   &
     n_a, n_r, k_mu, start
 IMPLICIT NONE
@@ -75,11 +76,11 @@ DATA IZ(36:56) /0,0,5,0,1,0,1,4,4,0,2,0,2,3,3,1,1,3,1,2,2/
 INTEGER, ALLOCATABLE :: limit(:)
 REAL(dp), ALLOCATABLE :: xs(:,:), radius(:), q(:,:)
 REAL(dp) :: rt(0:20), binom(0:20,0:20), rtbinom(0:20,0:20),         &
-    d(56,56)
+    d(56,56), qt(0:121)
 
 LOGICAL:: slice, linear, planar, general
 INTEGER :: ns, lmax, perp, mindc, maxdc
-REAL(dp) :: tol
+REAL(dp) :: tol, spread
 
 !  Charge density at grid points
 REAL(dp), ALLOCATABLE :: rho(:)
@@ -325,11 +326,30 @@ DATA W(191:210) /                                          &
     4.39934099227335D-10, 2.22939364553444D-13/
 
 CONTAINS
-
+!-------------------------------------------------------------
+! Some getter functions to access the DMA information from C
+INTEGER(C_INT) FUNCTION get_nsites() BIND(c, name='get_nsites')
+    get_nsites = ns
+END FUNCTION get_nsites
+
+INTEGER(C_INT) FUNCTION get_order(site) BIND(c, name='get_order')
+    INTEGER(C_INT), VALUE, INTENT(IN) :: site
+    get_order = limit(site)
+END FUNCTION get_order
+
+REAL(C_DOUBLE) FUNCTION get_dma_value(site, addr) BIND(c, name='get_dma_value')
+    INTEGER(C_INT), VALUE, INTENT(IN) :: site, addr
+    get_dma_value = q(addr,site)
+END FUNCTION get_dma_value
+
+REAL(C_DOUBLE) FUNCTION get_tot_value(addr) BIND(c, name='get_tot_value')
+    INTEGER(C_INT), VALUE, INTENT(IN) :: addr
+    get_tot_value = qt(addr)
+END FUNCTION get_tot_value
 !-----------------------------------------------------------------   DMA
 
-SUBROUTINE dma_main(w,kp)
-USE common_routines
+SUBROUTINE dma_main(w,kp,infile,outfile)
+USE input
 IMPLICIT NONE
 !-----------------------------------------------------
 !     Copyright A J Stone University of Cambridge 1983
@@ -337,7 +357,7 @@ IMPLICIT NONE
 !     Version for Cadpac5 , R D Amos, June 1990
 !-----------------------------------------------------
 REAL(dp) :: w(*)
-INTEGER :: kp, prank=5
+INTEGER :: kp, prank=5, infile, outfile
 
 !                      Distributed Multipole Analysis
 
@@ -365,9 +385,9 @@ CHARACTER(LEN=16) :: wa, wb, wc
 
 LOGICAL :: check
 
-INTEGER :: kr=0, nerror=0, itol, zs(MAXS)
+INTEGER :: iw=6, kr=0, kw=0, nerror=0, itol, zs(MAXS)
 INTEGER :: i, j, k, l, m, ok
-REAL(dp) :: r, ox=0d0, oy=0d0, oz=0d0, qt(0:121)
+REAL(dp) :: r, ox=0d0, oy=0d0, oz=0d0!, qt(0:121)
 
 !  Directive syntax:
 !   MULTIPOLES
@@ -464,7 +484,9 @@ REAL(dp) :: r, ox=0d0, oy=0d0, oz=0d0, qt(0:121)
 !          linear molecules this procedure is always used.
 
 lmax=20
+iw=outfile
 kr=0
+kw=0
 linear=.false.
 planar=.false.
 general=.false.
@@ -472,6 +494,7 @@ perp=0
 itol=18
 nuclei=.true.
 slice=.false.
+spread=1.0d0
 bigexp=bigexp_default
 lebedev=.true.
 nerror=0
@@ -495,10 +518,10 @@ call atom_sites
 !  Read input keywords
 do
   if (nerror .eq. 1) then
-    print '(a)', 'Syntax checking only from this point.'
+    write(outfile, '(a)') 'Syntax checking only from this point.'
     nerror=nerror+1
   endif
-  call read_line(eof)
+  call read_line(eof, infile)
   call readu(wa)
   select case(wa)
   case('ATOMS')  !  Default choice of sites
@@ -508,7 +531,7 @@ do
   case('START')
     exit
   case('LINEAR')
-    PRINT '(/A)', 'The LINEAR option is no longer needed'
+    write(outfile, '(/A)') 'The LINEAR option is no longer needed'
   case('PLANAR')
     call readu(wb)
     select case(wb)
@@ -540,6 +563,10 @@ do
     planar=.false.
     perp=0
 
+  case('SPREAD')
+    call readf(spread,rfact)
+    if (spread .eq. 0.0d0) spread=1.0d0
+
   case("GRID")
     do while (item < nitems)
       call readu(wa)
@@ -760,13 +787,13 @@ do
   case("BIGEXP","SWITCH")
     call readf(bigexp)
     if (bigexp < 0d0) then
-      print "(a)", "Switch value must not be negative"
+      write(outfile, "(a)") "Switch value must not be negative"
       nerror=nerror+1
     end if
     if (bigexp > 0d0) general=.true.
 
   case default
-    print '(a,a)', 'Unrecognised DMA keyword ', wa
+    write(outfile, '(a,a)') 'Unrecognised DMA keyword ', wa
     nerror=nerror+1
   end select
 end do
@@ -809,20 +836,20 @@ write (iw,"(/25x,a/)") "Distributed Multipole Analysis"
 Q=0.0d0
 
 if (bigexp > 0d0) then
-  print "(a,a,f0.5)", "Standard DMA for products of primitives",  &
+  write(outfile, "(a,a,f0.5)") "Standard DMA for products of primitives",  &
       " with exponent greater than ", bigexp
   general=.true.
-  call make_grid(ns, zs, xs, radius)
+  call make_grid(ns, zs, xs, radius, outfile)
   if (allocated(rho)) then
     deallocate(rho)
   end if
   allocate(rho(ng), stat=ok)
   if (ok>0) then
-    print "(a)", "Allocation of density grid failed"
+    write(outfile, "(a)") "Allocation of density grid failed"
     stop
   end if
 else
-  print "(a)", "Standard DMA"
+  write(outfile, "(a)") "Standard DMA"
 end if
 
 if (general) then
@@ -832,18 +859,20 @@ if (general) then
   perp=0
 end if
 
-print "(/2a)", "Positions and radii in ", trim(runit)
+write(outfile, "(/2a)") "Positions and radii in ", trim(runit)
 
 if (Qfactor(0) .ne. 1d0) then
-  print "(/a)", "Multipole moments are in SI units, multiplied by 10^(10k+20) for rank k"
+  write(outfile, "(/a)") "Multipole moments are in SI units, multiplied by 10^(10k+20) for rank k"
 else
-  print "(a)", "Multipole moments in atomic units, ea_0^k for rank k"
+  write(outfile, "(a)") "Multipole moments in atomic units, ea_0^k for rank k"
 end if
 
 if (linear) then
-  call dmaql0(w,kr)
+  !call dmaql0(w,kr)
+  call dmaql0(w,kw)
 else
-  call dmaqlm(w,kr)
+  !call dmaqlm(w,kr)
+  call dmaqlm(w,kw)
 endif
 
 qt=0.0d0
@@ -929,7 +958,7 @@ END SUBROUTINE dma_main
 
 !---------------------------------------------------------------  DMAQL0
 
-SUBROUTINE dmaql0(densty,kr)
+SUBROUTINE dmaql0(densty,iw)
 IMPLICIT NONE
 !-----------------------------------------------------
 !     Copyright A J Stone University of Cambridge 1983
@@ -937,7 +966,7 @@ IMPLICIT NONE
 !     Version for Cadpac5 , R D Amos, June 1990
 !-----------------------------------------------------
 REAL(dp), INTENT(IN) :: densty(*)
-INTEGER, INTENT(IN) :: kr
+INTEGER, INTENT(IN) :: iw
 
 
 !  Calculate multipole moments, and shift them to the nearest site. In
@@ -1013,7 +1042,8 @@ do i=1,nat
   zi=c(3,i)
   if (nuclei .and. i .ge. mindc .and. i .le. maxdc) then
     qt(0)=zan(i)
-    call movez(qt, zi, kr)
+    !call movez(qt, zi, kr)
+    call movez(qt, zi, iw)
   endif
   !  Find shells for atom i
   ii1=0
@@ -1150,7 +1180,7 @@ do i=1,nat
             zp=zi-p*zji
             za=zi-zp
             zb=zj-zp
-            if (iand(kr,2) .ne. 0) write (iw,"(3(i5,i4), f11.4)")              &
+            if (iw .gt. 0) write (iw,"(3(i5,i4), f11.4)")              &
                 i,j, ii,jj, ig,jg, zp
 !  Use numerical integration to evaluate the multipole integrals
 !  over x and y (they are the same).
@@ -1215,7 +1245,7 @@ do i=1,nat
 !  End of loop over basis functions
                   end do
                 end do
-                if (iand(kr,1) .ne. 0) write (iw,"(a,i3, 11f11.7)")            &
+                if (iw .gt. 0) write (iw,"(a,i3, 11f11.7)")            &
                     "slice", is, (qt(iq), iq=0,min(lmax,10))
 !  Move multipoles to expansion site contained in this slice.
 !  Note that they are currently referred to the overlap centre P.
@@ -1275,22 +1305,22 @@ do i=1,nat
                   if (mod(mx,2) .eq. 0 .and. mod(my,2) .eq. 0)         &
                       call addql0 (qt, min(nq,lmax), -fac*ci*cj*d(ia,jb), &
                       gx(mx),gx(my),gz(0,iz(ia),iz(jb)))
-                  if (iand(kr,2) .ne. 0) write (iw,"(1p,3e10.2,2i3,1p,4e10.2)") &
+                  if (iw .gt. 0) write (iw,"(1p,3e10.2,2i3,1p,4e10.2)") &
                       fac, ci, cj, ia, jb, d(ia,jb),                   &
                       gx(mx), gx(my), gz(0,iz(ia),iz(jb))
 !  End of loop over basis functions
                 end do
               end do
-              if (iand(kr,1) .ne. 0) write (iw,"(3(i5,i4), f11.4, 3x, 11f12.8)") &
+              if (iw .gt. 0) write (iw,"(3(i5,i4), f11.4, 3x, 11f12.8)") &
                   i,j, ii,jj, ig,jg, zp, (qt(iq), iq=0,10)
 !  Move multipoles to nearest site.
-              call movez(qt, zp, kr)
+              call movez(qt, zp, iw)
             endif
 !  End of loop over primitives
           end do
         end do
-        if (iand(kr,1) .ne. 0) write (iw,"(/(5f15.8))") (q(0:4,ia), ia=1,ns)
-        if (iand(kr,1) .ne. 0) write (iw,"(1x)")
+        if (iw .gt. 0) write (iw,"(/(5f15.8))") (q(0:4,ia), ia=1,ns)
+        if (iw .gt. 0) write (iw,"(1x)")
 !  End of loop over shells
       end do
     end do
@@ -1428,7 +1458,7 @@ END SUBROUTINE shiftz
 
 !----------------------------------------------------------------- MOVEZ
 
-SUBROUTINE movez (qp, p, kr)
+SUBROUTINE movez (qp, p, iw)
 IMPLICIT NONE
 !-----------------------------------------------------
 !     Copyright A J Stone University of Cambridge 1983
@@ -1439,7 +1469,7 @@ IMPLICIT NONE
 !  to the nearest site.
 REAL(dp), INTENT(INOUT) :: qp(0:)
 REAL(dp), INTENT(IN) :: p
-INTEGER, INTENT(IN) :: kr
+INTEGER, INTENT(IN) :: iw
 
 REAL(dp) :: r(maxs)
 REAL(dp), PARAMETER :: eps=1d-8
@@ -1467,7 +1497,7 @@ do
     m(2)=i
   end do
 !  Multipoles of ranks LOW to LIMIT(K) are to be moved at this stage
-  if (iand(kr,2) .ne. 0) write (6,1001) p, low, limit(k),                   &
+  if (IW .gt. 0) write (6,1001) p, low, limit(k),                   &
       (m(i), xs(3,m(i)), i=1,n)
 1001  format (' From', F7.3, ': ranks', I3, ' to', I3,                  &
           ' to be moved to site ', I1, ' at', F7.3:                     &
@@ -1620,10 +1650,10 @@ END SUBROUTINE dmaerf
 
 !-----------------------------------------------------------------DMAQLM
 
-SUBROUTINE dmaqlm(densty,kr)
+SUBROUTINE dmaqlm(densty,iw)
 IMPLICIT NONE
 REAL(dp), INTENT(IN) :: densty(*)
-INTEGER, INTENT(IN) :: kr
+INTEGER, INTENT(IN) :: iw
 
 !-----------------------------------------------------
 !     Copyright A J Stone University of Cambridge 1983
@@ -1691,7 +1721,7 @@ REAL(dp) :: aa, ai, arri, aj, ci, cj, ch, dum, e, fac, f, g,           &
 
 do_quadrature=.false.
 
-if (iand(kr,1) .ne. 0) print "(a/a)",                                           &
+if (iw .gt. 0) write(iw, "(a/a)")                                      &
     '    Atoms   Shells Primitives            Position',               &
     '     Multipole contributions ...'
 katom(nshell+1)=0
@@ -1782,7 +1812,7 @@ do i=1,nat
           end if
         end do
 
-        if (iand(kr,8) .ne. 0 .and. la == 5) then
+        if (iw .gt. 0 .and. la == 5) then
           !  Print out temporary density matrix
           print "(4i4)", i, j, la, lb
           do mi = mini,maxi
@@ -1872,7 +1902,7 @@ do i=1,nat
               yp=yi-ya
               zp=zi-za
               t=sqrt(1.0d0/aa)
-              if (iand(kr,2) .ne. 0) print ("(3(i5,i4), 3x, 3f10.5)"),      &
+              if (iw .gt. 0) write(iw, "(3(i5,i4), 3x, 3f10.5)")      &
                   i,j, ii,jj, ig,jg, xp,yp,zp
 !  LQ is the maximum rank of multipole to which these functions
 !  contribute. The integrals involve polynomials up to order 2LQ,
@@ -1947,7 +1977,7 @@ do i=1,nat
                 end do
               end do
 
-              if (iand(kr,1) .ne. 0) print "(f10.6: / 3f10.6: / 5f10.6: / 7f10.6: / 9f10.6: /&
+              if (iw .gt. 0) print "(f10.6: / 3f10.6: / 5f10.6: / 7f10.6: / 9f10.6: /&
                   & 11f10.6: / 13f10.6: / 15f10.6: / 17f10.6: / 19f10.6: / 21f10.6)", &
                   qt(1:(nq+1)**2)
 !  Move multipoles to expansion centre nearest to overlap centre P.
@@ -1967,7 +1997,7 @@ do i=1,nat
               xp=xi-p*xji
               yp=yi-p*yji
               zp=zi-p*zji
-              if (iand(kr,2) .ne. 0) print "(2i5, 3f20.15)", ig, jg, xp, yp, zp
+              if (iw > 0) write(iw, "(2i5, 3f20.15)") ig, jg, xp, yp, zp
               do k=1,ng
                 xk=grid(1,k)
                 yk=grid(2,k)
@@ -2889,7 +2919,7 @@ REAL(dp) :: a2kp1, rr, rfx, rfy, rfz, s
 
 l=iabs(j)
 if ((l+1)**2 .gt. max) then
-  print '(a,i3)', 'Insufficient array space for harmonics up to rank',L
+  write(6,'(a,i3)') 'Insufficient array space for harmonics up to rank',L
   call die('Consult authors')
 endif
 rr=x**2+y**2+z**2
diff --git a/src/exe.f90 b/src/exe.f90
new file mode 100644
index 0000000..ab74356
--- /dev/null
+++ b/src/exe.f90
@@ -0,0 +1,163 @@
+program gdma
+
+USE input
+USE version
+USE dma
+USE atom_grids, ONLY: debug_grid => debug
+USE timing, ONLY: start_timer, timer, time_and_date
+use libgdma
+!IMPLICIT NONE
+!
+!INTEGER, PARAMETER :: dp=kind(1d0)
+!
+!CHARACTER(LEN=100) :: file
+!CHARACTER(LEN=80) :: buffer
+!CHARACTER(LEN=20) :: key
+!CHARACTER(LEN=8) :: whichd="SCF"
+!CHARACTER(LEN=24) :: datestring
+!
+!!  Maximum number of sites is number of atoms + nextra
+!INTEGER :: nextra=16
+!INTEGER :: ncoorb, maxl, cmax, nprim, nx, num, ich, mul
+!INTEGER, ALLOCATABLE :: shell_type(:)
+!INTEGER :: i, j, k, kp=0
+!LOGICAL :: eof, fchk, first, ok=.false.
+!
+!REAL(dp), ALLOCATABLE :: densty(:,:), dtri(:)
+!INTEGER :: ir=5 ! Input stream
+!
+!LOGICAL :: verbose=.false., debug(0:2)=.false.
+
+
+print "(15x,a/15x,a//15x,a//15x,5a/14x,4a)",                           &
+    "                      G D M A",                                   &
+    "                  by Anthony Stone",                              &
+    "Distributed Multipoles from Gaussian wavefunctions",              &
+    "              version ", gdma_version, " (", commit, ")",         &
+    "Compiled with ", compiler, " on ", compiled
+call time_and_date(datestring)
+print "(/2A)", "Starting at ", datestring
+
+call start_timer
+
+punchfile="dma.punch"
+nat=0
+fchk=.false.
+first=.true.
+do
+  call read_line(eof)
+  if (eof) exit
+  call readu(key)
+  select case(key)
+  case("","NOTE","!")
+    cycle
+  case("VERBOSE")
+    verbose=.true.
+  case("QUIET")
+    debug=.false.
+    verbose=.false.
+  case("DEBUG")
+    debug(0)=.true.
+    do while (item<nitems)
+      call readi(k)
+      if (k>0) then
+        debug(k)=.true.
+      else
+        debug(-k)=.false.
+      end if
+    end do
+    debug_grid=.true.
+    verbose=.true.
+  case("ANGSTROM")
+    rfact=bohr
+  case("BOHR")
+    rfact=1d0
+  case("SI")
+    Qfactor(0)=echarge
+    do k=1,20
+      Qfactor(k)=Qfactor(k-1)*bohr
+    end do
+  case("AU")
+    Qfactor=1d0
+  case("COMMENT","TITLE")
+    call reada(buffer)
+    print "(/a/)", trim(buffer)
+  case("DENSITY")
+    if (fchk) call die                                         &
+        ("Specify density to use before reading data file",.true.)
+    call readu(whichd)
+  case("FILE","READ")
+    nat=0
+    fchk=.false.
+    ok=.false.
+    first=.true.
+    if (allocated(dtri)) deallocate(dtri)
+    do while (item<nitems)
+      call readu(key)
+      select case(key)
+      case("DENSITY")
+        call readu(whichd)
+      case default
+        call reread(-1)
+        call reada(file)
+        open(unit=9,file=file,status="old",iostat=k)
+        if (k .ne. 0) then
+          call die("Can't open file "//file,.true.)
+        endif
+      end select
+    end do
+    ir=9
+    call get_data(whichd,ok,5)
+    close(9)
+    ir=5
+    fchk=.true.
+  case ("HERE")
+    call get_data(whichd,ok,5)
+    fchk=.true.
+  case("NAMES")
+    if (.not. fchk) call die                                   &
+        ("Read data file before specifying atom names",.false.)
+    call read_line(eof)
+    do i=1,nat
+      call geta(name(i))
+    end do
+  case("GO","START","MULTIPOLES")
+    if (.not. ok) then
+      call die (trim(whichd)//" density not found",.false.)
+    endif
+    if (first) then
+      ! convert density matrix to triangular form
+      allocate(dtri(nx))
+      k=0
+      do i=1,num
+        do j=1,i
+          k=k+1
+          dtri(k)=densty(i,j)
+        end do
+      end do
+      deallocate(densty)
+      first=.false.
+    endif
+    print "(//2A/)", "Using "//trim(whichd)//" density matrix",  &
+        " from file "//trim(file)
+    call dma_main(dtri,kp,5,6)
+    call timer
+  case("RESET")
+    nat=0
+    fchk=.false.
+    ok=.false.
+    first=.true.
+    deallocate(dtri)
+    whichd="SCF"
+  case("FINISH")
+    exit
+  case default
+    call die("Keyword "//trim(key)//" not recognized",.true.)
+  end select
+end do
+
+call time_and_date(datestring)
+print "(/2A)", "Finished at ", datestring
+
+END program gdma
+
diff --git a/src/gdma.f90 b/src/gdma.f90
index ae1d545..4c1dc67 100644
--- a/src/gdma.f90
+++ b/src/gdma.f90
@@ -1,4 +1,5 @@
-PROGRAM gdma
+module libgdma
+!program gdma
 
 !  Distributed Multipole Analysis for Gaussian Wavefunctions
 !
@@ -18,8 +19,13 @@ PROGRAM gdma
 !  along with this program; if not, write to
 !  the Free Software Foundation, Inc., 51 Franklin Street,
 !  Fifth Floor, Boston, MA 02110-1301, USA.
+!
+!  This version has been modified by Andy Simmonett (03/16) to link
+!  into Psi4, rather than serve as a standalone executable.
 
 USE input
+use iso_c_binding
+use iso_fortran_env, only : std_out=>output_unit
 USE version
 USE dma
 USE atom_grids, ONLY: debug_grid => debug
@@ -40,21 +46,74 @@ INTEGER :: ncoorb, maxl, cmax, nprim, nx, num, ich, mul
 INTEGER, ALLOCATABLE :: shell_type(:)
 INTEGER :: i, j, k, kp=0
 LOGICAL :: eof, fchk, first, ok=.false.
+INTEGER open_status, infile
 
 REAL(dp), ALLOCATABLE :: densty(:,:), dtri(:)
 INTEGER :: ir=5 ! Input stream
 
 LOGICAL :: verbose=.false., debug(0:2)=.false.
 
+CONTAINS
+
+
+subroutine run_gdma(c_outfilename, c_datfilename) bind(c, name='run_gdma')
+!character(kind=c_char,len=1), intent(in) :: c_outfilename
+CHARACTER(kind=C_CHAR) :: c_outfilename(*), c_datfilename(*)
+character(len=:), allocatable :: outfilename, datfilename
+integer i, nchars
+integer outfile
+
+i = 1
+do
+   if (c_outfilename(i) == c_null_char) exit
+   i = i + 1
+end do
+nchars = i - 1  ! Exclude null character from Fortran string
+!allocate(character(len=nchars) :: outfilename)
+outfilename = (repeat(' ', nchars))
+outfilename = transfer(c_outfilename(1:nchars), outfilename)
+i = 1
+do
+   if (c_datfilename(i) == c_null_char) exit
+   i = i + 1
+end do
+nchars = i - 1  ! Exclude null character from Fortran string
+!allocate(character(len=nchars) :: datfilename)
+datfilename = (repeat(' ', nchars))
+datfilename = transfer(c_datfilename(1:nchars), datfilename)
 
-print "(15x,a/15x,a//15x,a//15x,5a/14x,4a)",                           &
+!
+! Added file IO (ACS 03/16)
+!
+infile = 51
+outfile = 52
+open (unit=infile, file=datfilename, status='old', &
+    iostat=open_status, action='read', position='rewind')
+if ( open_status /= 0 ) then
+    write(outfile, *) 'Could not open GDMA input for reading.', &
+    'unit = ', infile
+    stop
+endif
+if(outfilename=='stdout') then
+  outfile=std_out
+else
+  open (unit=outfile, file=outfilename, status='old', &
+      iostat=open_status, action='write', position='append')
+  if ( open_status /= 0 ) then
+      write(outfile, *) 'Could not open psi4 output for writing.', &
+      'unit = ', infile
+      stop
+  endif
+endif
+!!!
+write(outfile, "(15x,a/15x,a//15x,a//15x,5a/14x,4a)")                  &
     "                      G D M A",                                   &
     "                  by Anthony Stone",                              &
     "Distributed Multipoles from Gaussian wavefunctions",              &
     "              version ", gdma_version, " (", commit, ")",         &
     "Compiled with ", compiler, " on ", compiled
 call time_and_date(datestring)
-print "(/2A)", "Starting at ", datestring
+write(outfile, "(/2A)") "Starting at ", datestring
 
 call start_timer
 
@@ -63,7 +122,7 @@ nat=0
 fchk=.false.
 first=.true.
 do
-  call read_line(eof)
+  call read_line(eof, infile)
   if (eof) exit
   call readu(key)
   select case(key)
@@ -99,7 +158,7 @@ do
     Qfactor=1d0
   case("COMMENT","TITLE")
     call reada(buffer)
-    print "(/a/)", trim(buffer)
+    write(outfile, "(/a/)") trim(buffer)
   case("DENSITY")
     if (fchk) call die                                         &
         ("Specify density to use before reading data file",.true.)
@@ -125,17 +184,17 @@ do
       end select
     end do
     ir=9
-    call get_data(whichd,ok)
+    call get_data(whichd,ok,outfile)
     close(9)
     ir=5
     fchk=.true.
   case ("HERE")
-    call get_data(whichd,ok)
+    call get_data(whichd,ok,outfile)
     fchk=.true.
   case("NAMES")
     if (.not. fchk) call die                                   &
         ("Read data file before specifying atom names",.false.)
-    call read_line(eof)
+    call read_line(eof, infile)
     do i=1,nat
       call geta(name(i))
     end do
@@ -156,9 +215,9 @@ do
       deallocate(densty)
       first=.false.
     endif
-    print "(//2A/)", "Using "//trim(whichd)//" density matrix",  &
+    write(outfile, "(//2A/)") "Using "//trim(whichd)//" density matrix",  &
         " from file "//trim(file)
-    call dma_main(dtri,kp)
+    call dma_main(dtri,kp,infile,outfile)
     call timer
   case("RESET")
     nat=0
@@ -175,17 +234,22 @@ do
 end do
 
 call time_and_date(datestring)
-print "(/2A)", "Finished at ", datestring
+write(outfile, "(/2A)") "Finished at ", datestring
+close(outfile)
+close(infile)
+end subroutine run_gdma
 
-CONTAINS
+
+!CONTAINS
 
 !-----------------------------------------------------------------------
 
-SUBROUTINE get_data(whichd,ok)
+SUBROUTINE get_data(whichd,ok,outfile)
 
 IMPLICIT NONE
 
 CHARACTER(LEN=*), INTENT(IN) :: whichd
+INTEGER, INTENT(IN) :: outfile
 LOGICAL, INTENT(OUT) :: ok
 
 INTEGER :: atom, i, j, k, n, nn, aok
@@ -220,6 +284,10 @@ CHARACTER(LEN=5) :: label(-5:5)=(/"h(s)","g(s)","f(s)","d(s)","sp  ",  &
 !  Conversion from normalised spherical form to normalised Cartesian
 !  Schlegel & Frisch, IJQC (1995) 54, 83-87.
 rt3v2=rt3/2d0
+!  d functions
+!   1   2   3   4   5   6
+!   xx  yy  zz  xy  xz  yz
+!  200 020 002 110 101 011
 td(1,:)=(/-0.5d0, -0.5d0, 1d0, 0d0, 0d0, 0d0/)
 td(2,:)=(/0d0,    0d0,    0d0, 0d0, 1d0, 0d0/)
 td(3,:)=(/0d0,    0d0,    0d0, 0d0, 0d0, 1d0/)
@@ -229,6 +297,7 @@ td(5,:)=(/0d0,    0d0,    0d0, 1d0, 0d0, 0d0/)
 !  f functions
 !   1   2   3   4   5   6   7   8   9   10
 !  xxx yyy zzz xxy xxz xyy yyz xzz yzz xyz
+!  300 030 003 210 201 120 021 102 012 111
 tf(:,:)=0d0
 ! 30
 tf(1,3)=1d0; tf(1,5)=-1.5d0/sqrt(5d0); tf(1,7)=-1.5d0/sqrt(5d0)
@@ -248,6 +317,8 @@ tf(7,2)=-sqrt(10d0)/4d0; tf(7,4)=0.75d0*sqrt(2d0)
 !  g functions
 !   1    2    3    4    5    6    7    8    9   10   11   12   13   14   15
 ! xxxx yyyy zzzz xxxy xxxz xyyy yyyz xzzz yzzz xxyy xxzz yyzz xxyz xyyz xyzz
+!  400  040  004  310  301  130  031  103  013  220  202  022  211  121  112
+!     12   23  D     23 23,12  13  23,12 12  D      23  12
 tg=0d0
 !  40
 tg(1,v400)=0.375d0; tg(1,v040)=0.375d0; tg(1,v004)=1d0
@@ -329,8 +400,8 @@ call stream(ir)
 read (ir,"(A80/A80)") title(1), title(2)
 density_header="Total "//trim(whichd)//" Density"
 if (verbose) then
-  print "(a/a/a/)", "Gaussian header:", trim(title(1)), trim(title(2))
-  print "(3a)", 'Looking for "', trim(density_header), '"'
+  write(outfile, "(a/a/a/)") "Gaussian header:", trim(title(1)), trim(title(2))
+  write(outfile, "(3a)") 'Looking for "', trim(density_header), '"'
 end if
 do
   read (ir,"(A)",iostat=k) buffer
@@ -338,7 +409,7 @@ do
     call stream(5)
     exit
   end if
-  if (debug(0)) print "(a)", buffer
+  if (debug(0)) write(outfile, "(a)") buffer
   text=buffer(1:40)
   type=buffer(44:44)
   ww=buffer(48:49)
@@ -347,7 +418,7 @@ do
   else
     nn=0
   endif
-  if (debug(0)) print "(a)", text
+  if (debug(0)) write(outfile, "(a)") text
   select case(text)
   case("")
     cycle
@@ -356,7 +427,7 @@ do
     exit
   case("Number of atoms")
     read(buffer,"(55X,I6)") nat
-    if (verbose) print "(i0,a)", nat, " atoms"
+    if (verbose) write(outfile, "(i0,a)") nat, " atoms"
     if (allocated(zan)) deallocate(zan,c)
     allocate(zan(nat),c(3,nat),stat=aok)
     if (aok>0) call die("Can't allocate atom arrays")
@@ -367,18 +438,18 @@ do
     if (aok>0) call die("Can't allocate site-name array")
   case("Charge")
     read(buffer,"(55X,I6)") ich
-    if (verbose) print "(a,i0)", "Charge ", ich
+    if (verbose) write(outfile, "(a,i0)") "Charge ", ich
   case("Multiplicity")
     read(buffer,"(55X,I6)") mul
-    if (verbose) print "(a,i0)", "Multiplicity ", mul
+    if (verbose) write(outfile, "(a,i0)") "Multiplicity ", mul
   case("Number of basis functions")
     read(buffer,"(55X,I6)") ncoorb
     !  This number may be increased following conversion from
     !  spherical to cartesian
-    if (verbose) print "(i0,a)", ncoorb, " basis functions"
+    if (verbose) write(outfile, "(i0,a)") ncoorb, " basis functions"
   case("Number of contracted shells")
     read(buffer,"(55X,I6)") nshell
-    if (verbose) print "(i0,a)", nshell, " shells"
+    if (verbose) write(outfile, "(i0,a)") nshell, " shells"
     if (allocated(kstart))                                             &
         deallocate(kstart,katom,ktype,kng,kloc,kmin,kmax,shell_type)
     allocate (kstart(nshell), katom(nshell+1), ktype(nshell),          &
@@ -388,17 +459,17 @@ do
     shell_type=0
   case("Highest angular momentum")
     read(buffer,"(55X,I6)") maxl
-    if (verbose) print "(a,i0)", "Highest angular momentum ", maxl
+    if (verbose) write(outfile, "(a,i0)") "Highest angular momentum ", maxl
     if (maxl > 5) call die                                 &
         ("Sorry -- GDMA can only handle s, p, d, f, g and h basis functions",.false.)
   case("Largest degree of contraction")
     read(buffer,"(55X,I6)") cmax
-    if (verbose) print "(a,i0)", "Largest contraction depth ", cmax
+    if (verbose) write(outfile, "(a,i0)") "Largest contraction depth ", cmax
     ! if (cmax .gt. 16) call die                                &
     !     ("Sorry -- maximum contraction depth is 16",.false.)
   case("Number of primitive shells")
     read(buffer,"(55X,I6)") nprim
-    if (verbose) print "(i0,a)", nprim, " primitive shells"
+    if (verbose) write(outfile, "(i0,a)") nprim, " primitive shells"
     if (allocated(ex)) deallocate(ex,cs,cp)
     allocate(ex(nprim), cs(nprim), cp(nprim), stat=aok)
     if (aok>0) then
@@ -411,23 +482,23 @@ do
       call geti(k)
       name(i)=element(k)
     end do
-    if (verbose) print "(a,20a3/(17x,20a3))",                    &
+    if (verbose) write(outfile, "(a,20a3/(17x,20a3))")                    &
         "Atoms:            ", name(1:nat)
   case("Nuclear charges")
     call read_line(eof)
     do i=1,nat
       call getf(zan(i))
     end do
-    if (verbose) print "(a,20i3/(16x,20i3))",                    &
+    if (verbose) write(outfile, "(a,20i3/(16x,20i3))")                    &
         "Nuclear charges:", nint(zan(1:nat))
   case("Current cartesian coordinates")
     call read_line(eof)
-    if (verbose) print "(a)", "Atom  Z   Position (a.u.)"
+    if (verbose) write(outfile, "(a)") "Atom  Z   Position (a.u.)"
     do i=1,nat
       do j=1,3
         call getf(c(j,i),rfact)
       end do
-      if (verbose) print "(a3,i4,3f10.5)", name(i), nint(zan(i)), c(:,i)
+      if (verbose) write(outfile, "(a3,i4,3f10.5)") name(i), nint(zan(i)), c(:,i)
     end do
   case("Shell types")
     call read_line(eof)
@@ -467,9 +538,9 @@ do
         num=num+13; n=n+28
       end select
     end do
-    if (verbose) print "(i0,a)", num, " basis functions"
+    if (verbose) write(outfile, "(i0,a)") num, " basis functions"
     if ((verbose) .and. n>num)                           &
-        print "(a,i0,a)", "(", n, " after conversion to cartesian)"
+        write(outfile, "(a,i0,a)") "(", n, " after conversion to cartesian)"
     maxbfn = n
     if (allocated(iax)) deallocate(iax)
     allocate(iax(n+1), stat=aok)
@@ -486,8 +557,8 @@ do
       kng(i)=j
     end do
     if (verbose) then
-      print "(a,20i3/(19x,20i3))", "Contraction depths:", kng(1:nshell)
-      print "(a,i0)", "Total number of primitives required: ", k-1
+      write(outfile, "(a,20i3/(19x,20i3))") "Contraction depths:", kng(1:nshell)
+      write(outfile, "(a,i0)") "Total number of primitives required: ", k-1
     end if
     if (k .ne. nprim+1) call die                              &
         ("Shell contractions do not match number of primitives",.false.)
@@ -496,6 +567,9 @@ do
     do i=1,nshell
       call geti(katom(i))
     end do
+    if (verbose) then
+      write(outfile, "(a,120i3)") "shell to atom", katom(1:nshell)
+    endif
   case("Primitive exponents")
     call read_line(eof)
     do i=1,nprim
@@ -534,7 +608,7 @@ do
     end do
 !   case("Alpha MO coefficients","Beta MO coefficients")
 !     if (debug(2)) then
-!       print "(/a)", text
+!       write(outfile, "(/a)") text
 !       allocate(temp(ncoorb,ncoorb))
 !       do i=1,ncoorb
 !         do j=1,ncoorb
@@ -578,19 +652,19 @@ if (verbose) then
   do i=1,nshell
     if (katom(i) .ne. atom) then
       atom=katom(i)
-      print "(a)", name(atom)
+      write(outfile, "(a)") name(atom)
     end if
-    print "(a,i0,3x,a)", "Shell ", i, label(shell_type(i))
+    write(outfile, "(a,i0,3x,a)") "Shell ", i, label(shell_type(i))
     do j=kstart(i),kstart(i)+kng(i)-1
       select case (shell_type(i))
       case (-1)
-        print "(i10,f16.8, 2f14.8)", j, ex(j), cs(j), cp(j)
+        write(outfile, "(i10,f16.8, 2f14.8)") j, ex(j), cs(j), cp(j)
       case(0)
-        print "(i10,f16.8, 2f14.8)", j, ex(j), cs(j)
+        write(outfile, "(i10,f16.8, 2f14.8)") j, ex(j), cs(j)
       case(1)
-        print "(i10,f16.8, 2f14.8)", j, ex(j), cp(j)
+        write(outfile, "(i10,f16.8, 2f14.8)") j, ex(j), cp(j)
       case default
-        print "(i10,f16.8, 2f14.8)", j, ex(j), cs(j)
+        write(outfile, "(i10,f16.8, 2f14.8)") j, ex(j), cs(j)
       end select
     end do
   end do
@@ -672,7 +746,7 @@ do i=1,nshell
     kmin(i)=21
     kmax(i)=35
     ktype(i)=5
-    ! print "(a,i0,a,i0)", "num = ", num, "  k = ", k
+    ! write(outfile, "(a,i0,a,i0)") "num = ", num, "  k = ", k
     if (shell_type(i) .lt. 0) then ! Spherical g shell
       temp(1:num,1:k)=densty(1:num,1:k)
       temp(1:num,k+1:k+15)=matmul(densty(1:num,k+1:k+9),tg)
@@ -686,7 +760,7 @@ do i=1,nshell
     kmin(i)=36
     kmax(i)=56
     ktype(i)=6
-    ! print "(a,i0,a,i0)", "num = ", num, "  k = ", k
+    ! write(outfile, "(a,i0,a,i0)") "num = ", num, "  k = ", k
     if (shell_type(i) .lt. 0) then ! Spherical h shell
       temp(1:num,1:k)=densty(1:num,1:k)
       temp(1:num,k+1:k+21)=matmul(densty(1:num,k+1:k+11),th)
@@ -747,4 +821,5 @@ end do
 
 END SUBROUTINE matwrtt
 
-END PROGRAM gdma
+END module libgdma
+
diff --git a/src/input.F90 b/src/input.F90
index 10e60b4..a999cbb 100644
--- a/src/input.F90
+++ b/src/input.F90
@@ -628,7 +628,11 @@ else
   m=char(l:end(item))
   length=end(item)-l+1
 endif
-if (len(m) .lt. length) print "(A)", "WARNING: string truncated"
+!if (len(m) .lt. length) print "(A)", "WARNING: string truncated"
+! LAB Jun 2018 -- it reads longish (40 char) files twice, apparently
+!   correctly, but doesn't set `m` right, so the lengths don't align,
+!   so it reads it again, this time in full. I can't understand it,
+!   and appears harmless so I'm silencing the warning.
 
 END SUBROUTINE reada
 
diff --git a/src/version.py b/src/version.py
index a57c046..2a7fb92 100755
--- a/src/version.py
+++ b/src/version.py
@@ -1,4 +1,4 @@
-#!/usr/bin/python3
+#!/usr/bin/env python
 #  -*-  coding:  utf-8  -*-
 
 """Construct the version.f90 file that contains version details.
@@ -23,6 +23,7 @@ description="""Construct the version.f90 file that contains version details.
 parser.add_argument("vfile", help="VERSION file path")
 parser.add_argument("v90", help="version.f90 file path")
 parser.add_argument("compiler", help="Compiler")
+parser.add_argument("--commit", help="commit to avoid git", default="use_git")
 
 args = parser.parse_args()
 
@@ -33,9 +34,12 @@ with open(args.vfile) as IN:
   patchlevel = re.sub("PATCHLEVEL +:= +", "", line)
 
 now = datetime.today().strftime('%d %B %Y at %H:%M:%S')
-log = subprocess.check_output("git log -n 1 --oneline", shell=True,
-                              universal_newlines=True)
-commit = log.split()[0]
+if args.commit == "use_git":
+    log = subprocess.check_output("git log -n 1 --oneline", shell=True,
+                                  universal_newlines=True)
+    commit = log.split()[0]
+else:
+    commit = args.commit
 
 with open(args.v90,"w") as OUT:
   OUT.write(f"""MODULE version
-- 
2.34.1

